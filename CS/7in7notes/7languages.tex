    \documentclass[10pt, twocolumn, landscape]{article}
    \usepackage{fancyhdr, amsmath, amsthm, amssymb, mathtools, lastpage,
    hyperref, enumerate, graphicx, setspace, wasysym, upgreek, listings}
    % chancery
    \usepackage[margin=1in]{geometry}
    \newcommand{\scinot}[2]{#1\times10^{#2}}
    \newcommand{\bra}[1]{\left<#1\right|}
    \newcommand{\ket}[1]{\left|#1\right>}
    \newcommand{\dotp}[2]{\left<#1\,\middle|\,#2\right>}
    \newcommand{\rd}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}}
    \newcommand{\pd}[2]{\frac{\partial#1}{\partial#2}}
    \newcommand{\rtd}[2]{\frac{\mathrm{d}^2#1}{\mathrm{d}#2^2}}
    \newcommand{\ptd}[2]{\frac{\partial^2 #1}{\partial#2^2}}
    \newcommand{\norm}[1]{\left|\left|#1\right|\right|}
    \newcommand{\abs}[1]{\left|#1\right|}
    \newcommand{\pvec}[1]{\vec{#1}^{\,\prime}}
    \newcommand{\svec}[1]{\vec{#1}\;\!}
    \newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}
    \let\Re\undefined
    \let\Im\undefined
    \newcommand{\ang}[0]{\text{\AA}}
    \newcommand{\mum}[0]{\upmu \mathrm{m}}
    \DeclareMathOperator{\Res}{Res}
    \DeclareMathOperator{\Re}{Re}
    \DeclareMathOperator{\Im}{Im}
    \DeclareMathOperator{\Log}{Log}
    \DeclareMathOperator{\Arg}{Arg}
    \DeclareMathOperator{\Tr}{Tr}
    \DeclareMathOperator{\E}{E}
    \DeclareMathOperator{\Var}{Var}
    \DeclareMathOperator*{\argmin}{argmin}
    \DeclareMathOperator*{\argmax}{argmax}
    \DeclareMathOperator{\sgn}{sgn}
    \DeclareMathOperator{\diag}{diag}
    \newcommand{\expvalue}[1]{\left<#1\right>}
    \usepackage[labelfont=bf, font=scriptsize]{caption}\usepackage{tikz}
    \usepackage[font=scriptsize]{subcaption}
    \everymath{\displaystyle}
    \lstset{basicstyle=\ttfamily\footnotesize,frame=single,numbers=left}

\tikzstyle{circ} = [draw, circle, fill=white, node distance=3cm, minimum
height=2em]

\begin{document}

\onehalfspacing

\pagestyle{fancy}
\rhead{Yubo Su}
\cfoot{\thepage/\pageref{LastPage}}

\tableofcontents

\newpage

\section{Introduction}

\begin{itemize}
    \item Learn a language by answering the following questions:
        \begin{itemize}
            \item What is the typing model? Static dynamic, strong weak?
            \item What is the programming model? OOP, functionall, procedural,
                hybrid of which?
            \item How will you interact? Compiled, interpreted, VMs?
            \item Design constructs/core data structures? Pattern matching,
                collections, unification?
            \item Core features that make it unique?
        \end{itemize}

    \item The languages:
        \begin{itemize}
            \item Ruby---OOP representative.
            \item Io---concurrency constructs w/ simplicity, uniformity and
                minimality of syntax.
            \item Prolog---Parent to Erlang? Old. Nothing else mentioned.
            \item Scala---Functional + OOP to Java.
            \item Erlang---Functional w/ concurrency, distribution + fault
                tolerance \emph{right}. BAse of CouchDB.\@
            \item Clojure---On JVM, same concurrency as versioned dbs. Lisp
                dialect
            \item Haskell---Pure functional, archetypal typing model.
        \end{itemize}

    \item Glossary (to be all on the same page):
        \begin{description}
            \item[Interpreted] Executed by an interpreter rather than a
                compiler.
            \item[Strongly Typed] Errors when types collide.
            \item[Dynamically Typed] Types bound at runtime rather than compile
                time. Generally means types inside functions are only checked on
                execution.
            \item[Duck Typing] If an object has a function then that function is
                invokable without type checking for the parent.
            \item[Object Oriented] Encapsulation (data + behavior together),
                inheiritance and polymorphism.
            \item[Prototype Language] Every object is a clone of another, a
                style of OOP.\@
            \item[Declarative Language] ``Throw facts and inferences at the
                language and it will reason for you.''
        \end{description}
\end{itemize}

\section{Ruby}

\begin{itemize}
    \item Optimized w/ syntactic sugar, programmer efficiency.
    \item Interpreted, OOP, dynamically typed, strongly typed, duck
        typed scripting language.
    \item Every piece of code returns, even if only \texttt{nil}.
        \begin{itemize}
            \item Functions return the value of the last expression.
        \end{itemize}
    \item Purely OOP, e.g.\ \texttt{4.class = Fixnum} and has methods viewable
        by \texttt{4.methods}.
    \item \texttt{if}, \texttt{unless}, \texttt{while}, \texttt{until} can be
        used either inline or in block form.
    \item \texttt{nil}, \texttt{false} are only falsey values, \texttt{0} is
        true!
    \item Each object natively understands equality.
    \item \emph{Symbols} are prefixed with \texttt{:identifier}. Identical
        symbols point to the same physical object, unlike identical objects, can
        tell by checking their \texttt{:identifier.object\_id}.
    \item Arrays are Ruby's primary ordered collection (Ruby 1.9 has ordered
        hashes).
        \begin{itemize}
            \item Out of bounds yields \texttt{nil}.
            \item Negative counts backwards.
            \item \texttt{arr[0..1]} returns a slice, since \texttt{0..1} is a
                \texttt{Range}.
            \item \texttt{[]} is a function on \texttt{Array}.
            \item No need to be homogeneous types.
            \item Implement queue, LL, stack, se etc.\@
        \end{itemize}
    \item Hashes are labeled collections, key-value pairs.
    \item \emph{Code blocks}
        \begin{itemize}
            \item Code blocks are unnamed functions, between braces or
                \texttt{do/end}, former when single line, latter when multiple
                lines.
            \item Can be passed as function argument, prototype says
                \texttt{\&block} and can invoke with \texttt{block.call}.
            \item \texttt{yield} calls whatever block is passed to the function.
            \item Can be used for delaying execution and conditional execution
                as well.
        \end{itemize}
    \item OOP
        \begin{itemize}
            \item \texttt{initialize} constructor
            \item Class names are camel cased, instance variables and method
                names are snake cased, constants all caps.
            \item Instance variables are prepended with a single \texttt{\@},
                class variables with two \texttt{\@\@}.
            \item \texttt{modules} to solve multiple inheritance, collection of
                functions and constants, \texttt{include}ed by \texttt{class}es.
            \item \texttt{modules} can call functions it does not define but
                expect \texttt{include}-ees to define, duck typing! Implicit
                ``abstract functions'' from Java.
        \end{itemize}
    \item \emph{Metaprogramming} is writing programs that write programs.
    \item \emph{Open Classes} allow us to modify existing classes in-line, even
        built-ins like \texttt{NilClass}.
        \begin{itemize}
            \item A fun use case is to override the
                \texttt{self.method\_missing} function, which is called whenever
                an attribute is not found. Then, a class called \texttt{Roman}
                can have attributes like \texttt{Roman.XII} and use
                \texttt{method\_missing} to compute the value! Wow! \smiley.
        \end{itemize}
    \item \texttt{Modules} are extremely adept at metaprogramming, since a
        modulee's \texttt{included} method is called whenever it is included, so
        it can metaprogram on inclusion.
    \item Core strengths
        \begin{itemize}
            \item Duck typed with OOP is out-of-the-box polymorphism.
            \item Fast for scripting, well-supported for various extensions.
            \item Rails!! Fast time to market.
        \end{itemize}
    \item Weaknesses
        \begin{itemize}
            \item Performance: getting much faster, but still slow.
                Metaprogramming makes any compilation nigh impossible. Also
                against the core design philosophy of programmer's experience vs
                performance.
            \item Concurrency is hard with OOP.\@
            \item No type safety.
        \end{itemize}
\end{itemize}

\section{Io}

\begin{itemize}
    \item Prototype language like Lua and Javascript, no distinction between
        objects and classes, developed in 2002.
    \item Everything is a message that returnss another receiver. Program by
        chaining messages, e.g.\ \texttt{"Hello World" print}. Message passing
        is a strong concurrency model.
    \item Objects and classes are the same, create new objects by cloning
        existing ones e.g.\ \texttt{Vehicle} \texttt{:= Object clone}.
        \begin{itemize}
            \item Inheritance is equivalent to sending the \texttt{clone}
                message to a parent prototype.
        \end{itemize}
    \item Objects have ``slots'', and a collection of slots is like a hash.
        Objects are basically collections of slots. Can \texttt{Object
        slotNames} to get list of slots.
    \item When a slot is not found on an object, it is forwarded up to parent
        prototypes or until not found.
    \item Lowercase clones do not override parent's \texttt{type} slot.
    \item \emph{Methods} are objects with \texttt{type} \texttt{Block}. Can be
        attached to object slots, are invoked when the slot is invoked.
    \item \texttt{Lobby} is an object with a slot for each name in the global
        namespace.
    \item Lists \texttt{list()} are the prototype for all ordered collections,
        and Maps \texttt{map()} are the prototype for all key value stores.
    \item \texttt{true, false, nil} are \emph{singletons}, i.e.\ their
        \texttt{clone} returns themselves rather than a clone of them! Lots of
        cool tricks by overriding core functionality like this.
    \item Can see list of operators directly with precedence by
        \texttt{OperatorTable} and create new operators. Use case: short JSON
        $\to$ \texttt{Map} parser.
    \item Message reflection is possible with the \texttt{call} operator inside
        method bodies, e.g.\ \texttt{call message arguments}.
        \begin{itemize}
            \item The reason message reflection works is because the full
                message context (sender, target, message) are all pushed onto
                the execution stack.
            \item In Io, messages passed as arguments to a method are only
                pushed onto the stack and \emph{not evaluated}.
            \item This means that a receiver can call \texttt{call sender *} and
                hit an arbitrary sender slot.
        \end{itemize}
    \item Can override \texttt{forward} message slot same way as
        \texttt{method\_missing} before.
    \item Concurrency
        \begin{itemize}
            \item \emph{Coroutines} are functions w/ multiple entry/exits. Firing a
                message with \texttt{\@} returns a future, with two
                \texttt{\@\@} returns \texttt{nil} and kicks off a new thread.
            \item \texttt{yield} yields control inside a coroutine.
            \item \emph{Actors} place incoming messages on a queue and dequeue
                with coroutines. An object becomes an actor when sent an
                asynchronous (\texttt{\@, \@\@}) message.
            \item \emph{Futures} return immediately, but when accessed block
                until the asynchronous result is returned.
        \end{itemize}
    \item Strengths
        \begin{itemize}
            \item Tiny footprint, heavily used for embedded systems.
            \item Compact syntax, fast rampup.
            \item Flexibility because all slots and operators are exposed.
        \end{itemize}
    \item Weaknesses
        \begin{itemize}
            \item Minimal syntactic sugar.
            \item Slow single-threaded execution speed.
        \end{itemize}
\end{itemize}

Illustrative example of reflection, to print slots of ancestors of any object
that clones \texttt{Object}:
\begin{lstlisting}
Object ancestors := method(
    prototype := self proto
    if(prototype != Object,
        writeln("Slots of ", prototype type)
        prototype slotNames forEach(name, writeln(slotName))
        writeln
        prototype ancestors
    )
)
\end{lstlisting}

\section{Prolog}

\begin{itemize}
    \item Declarative, from 1972.
    \item Three building blocks
        \begin{description}
            \item[Facts] Assertions about the world.
            \item[Rules] Inferences about facts in the described world.
            \item[Query] A question about the described world.
        \end{description}
    \item Facts and rules go into a \emph{knowledge base}, the Prolog compiler
        serializes facts and rules to be query efficient.
    \item First letter capitalization says whether an identifier is an
        \emph{atom}, fixed value like a Ruby symbol and capitalized, or
        \emph{variable} whose values can change and are lower cased or start
        with underscore.
\end{itemize}

\end{document}

